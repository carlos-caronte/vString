.TH "src/vstring.h" 3 "Tue Oct 17 2017" "Version 0.1" "vString" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/vstring.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBVstring\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBBUFFER_SIZE\fP   1024"
.br
.RI "Length of strings or capacity of our vstring objects\&. "
.ti -1c
.RI "#define \fB_s_assert\fP(X,  Y,  F,  LINE)"
.br
.ti -1c
.RI "#define \fBs_assert\fP(X,  Y)   \fB_s_assert\fP(X, Y, __FILE__, __LINE__)"
.br
.RI "Control of errors\&. "
.ti -1c
.RI "#define \fBforeach\fP(item,  array,  size)"
.br
.RI "A foreach bucle for arrays\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBS_safe\fP \fBsafe_t\fP"
.br
.ti -1c
.RI "typedef struct \fBVstring\fP \fBvstring_t\fP"
.br
.ti -1c
.RI "typedef \fBvstring_t\fP ** \fBarray_vstring_t\fP"
.br
.RI "An array of vstring objects\&. "
.ti -1c
.RI "typedef enum \fBS_stat\fP \fBs_stat\fP"
.br
.RI "Control of errors\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBS_safe\fP { \fBS_UNSAFE\fP = 0, \fBS_SAFE\fP = 1 }"
.br
.ti -1c
.RI "enum \fBS_stat\fP { \fBS_OK\fP = 0, \fBS_ERR_IS_EMPTY\fP = 1, \fBS_ERR_VALUE_NOT_FOUND\fP = 2, \fBS_ERR_OUT_OF_RANGE\fP = 3, \fBS_ERR_FILE\fP = 4, \fBS_ERR_STACK\fP = 5, \fBS_ERR_ALLOCATE_MEMORY\fP = 6, \fBS_ERR_MEMCPY\fP = 7, \fBS_ERR_MEMMOVE\fP = 8, \fBS_ERR_INVALID_ARGUMENT\fP = 9, \fBS_ERR_MAX_CAPACITY\fP = 10, \fBS_ERR_UNSAFE_CAPACITY\fP = 11, \fBS_ERR_OPEN_FILE\fP = 12 }
.RI "Control of errors\&. ""
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBvstring_t\fP * \fBvstring_New\fP (int capacity)"
.br
.RI "Constructor\&. There is no data in the vstring object\&. After 'New', you have to use 'From'\&. "
.ti -1c
.RI "\fBvstring_t\fP * \fBvstring_with_Capacity\fP (char *str, int capacity)"
.br
.RI "Constructor\&. We append the data array with 'str'\&. "
.ti -1c
.RI "void \fBvstring_Destroy\fP (\fBvstring_t\fP *s)"
.br
.RI "Destructor\&. "
.ti -1c
.RI "void \fBvstring_Destroy_Array\fP (\fBarray_vstring_t\fP s, int len)"
.br
.RI "Array destructor\&. "
.ti -1c
.RI "int \fBvstring_Capacity\fP (const \fBvstring_t\fP *s)"
.br
.RI "Returns the capacity of the specified object\&. The capacity is the maximum number of characters that an object can hold\&. Capacity has to be greater than Zero\&. "
.ti -1c
.RI "void \fBvstring_Count_words\fP (\fBvstring_t\fP *s, int *count)"
.br
.RI "Count the number of words in a vstring object\&. "
.ti -1c
.RI "const char const  * \fBvstring_Data\fP (const \fBvstring_t\fP *s)"
.br
.RI "Method to access the string in the vstring object\&. "
.ti -1c
.RI "bool \fBvstring_isEquals\fP (const \fBvstring_t\fP *s1, const \fBvstring_t\fP *s2)"
.br
.RI "It Compares the size of elements of two vstrings (s1, s2) and if are equals, it compares the first n bytes of memory area of s1->data and s2->data\&. "
.ti -1c
.RI "bool \fBvstring_isEmpty\fP (const \fBvstring_t\fP *s)"
.br
.RI "Returns True if object is Empty, that is, when its length is equal to Zero\&. "
.ti -1c
.RI "int \fBvstring_Len\fP (const \fBvstring_t\fP *s)"
.br
.RI "Returns the number of characters in the data object, the object's length\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_Pos_Err\fP (const \fBvstring_t\fP *s, int position)"
.br
.RI "Control if supplied position is out of range or object is empty\&. "
.ti -1c
.RI "int \fBvstring_Max_capacity\fP (const \fBvstring_t\fP *s)"
.br
.RI "Capacity bound\&. A proportional number over sizeof integer\&. "
.ti -1c
.RI "void \fBvstring_Array_print\fP (\fBvstring_t\fP *item, const \fBarray_vstring_t\fP array, int size)"
.br
.RI "Print an array of vstring objects\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_Begin\fP (const \fBvstring_t\fP *s, char *item)"
.br
.RI "Item at data's beginning\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_End\fP (const \fBvstring_t\fP *s, char *item)"
.br
.RI "Item at data's ending\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_At\fP (const \fBvstring_t\fP *s, char *item, int position)"
.br
.RI "Character at position in the vstring object\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_Pattern\fP (\fBvstring_t\fP *s, const char *pattern, \fBvstring_t\fP *result)"
.br
.RI "Returns the strings that matches the pattern in one vstring object\&. In this case, the search is, at least, Big-O lineal time of complexity\&. We use the C's library 'fnmatch' to pattern matching\&. The pattern may include the following special characters: "
.ti -1c
.RI "\fBarray_vstring_t\fP \fBvstring_Split\fP (\fBvstring_t\fP *s, int *len)"
.br
.RI "Split in words the vstring data object\&. The delimiter is SPACE\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_Capacity_edit\fP (\fBvstring_t\fP *s, int capacity)"
.br
.RI "To edit the capacity of the vstring object, but only if the object is S_UNSAFE and new capacity is lesser than MAX_CAPACITY\&. "
.ti -1c
.RI "void \fBvstring_Clear\fP (\fBvstring_t\fP *s)"
.br
.RI "Remove the data in the object, but it does not free the object\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_Clear_ifPattern\fP (\fBvstring_t\fP *s, const char *pattern)"
.br
.RI "Remove the data in the object, if matches the pattern\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_Concat\fP (\fBvstring_t\fP *s, \fBvstring_t\fP *t)"
.br
.RI "It concatenates two vstrings objects in the first object\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_From\fP (\fBvstring_t\fP *s, const char *str)"
.br
.RI "Insert (an item of data) at the end of vstring object\&. "
.ti -1c
.RI "void \fBvstring_Inmutable\fP (\fBvstring_t\fP *s)"
.br
.RI "Set the object vstring inmutable, that is, SAFE and capacity == len\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_From_at\fP (\fBvstring_t\fP *s, const char *str, int position)"
.br
.RI "Insert (an item of data) at position of vstring object\&. "
.ti -1c
.RI "void \fBvstring_From_file\fP (\fBvstring_t\fP *s, const char *filename)"
.br
.RI "We copy a file in a vstring object\&. In this case the object is UNSAFE\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_Rep\fP (\fBvstring_t\fP *s, size_t num)"
.br
.RI "It concatenates the source vstring object n times\&. "
.ti -1c
.RI "\fBs_stat\fP \fBvstring_Truncate\fP (\fBvstring_t\fP *s, int position)"
.br
.RI "It truncates the data object at position\&. "
.ti -1c
.RI "void \fBvstring_Unsafe\fP (\fBvstring_t\fP *s)"
.br
.RI "To edit the state of the vstring object\&. By default the data is inmutable, that is, we does not allow modify its capacity\&. "
.ti -1c
.RI "void \fBvstring_Abort\fP (\fBs_stat\fP status, const char *file, int line_number)"
.br
.RI "This function catcher errors that the macro s_assert throws\&. "
.ti -1c
.RI "int \fBvstring_Pos\fP (const \fBvstring_t\fP *s, int position)"
.br
.RI "It calculates new position if it is a negative number\&. "
.ti -1c
.RI "size_t \fBstr_Length\fP (char *src, int position, int length, char delimiter)"
.br
.RI "To calculate the lenght of substring in the buffer, from position, to position of the delimiter\&. "
.ti -1c
.RI "char * \fBstr_Substring\fP (char *string, int position, int length)"
.br
.RI "To identifie substrings in another string\&. "
.ti -1c
.RI "char * \fBstr_Repeat\fP (char *str, size_t count)"
.br
.RI "Copy in the string 'count' times the same string\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define _s_assert(X, Y, F, LINE)"
\fBValue:\fP
.PP
.nf
{                                                                                                             \
    if(!X){                                                                                                   \
        vstring_Abort(                                                                                        \
                Y,                                                                                            \
                F,                                                                                            \
                LINE);                                                                                        \
    }                                                                                                         \
}
.fi
.SS "#define BUFFER_SIZE   1024"

.PP
Length of strings or capacity of our vstring objects\&. 
.SS "#define foreach(item, array, size)"
\fBValue:\fP
.PP
.nf
for(int keep = 1, \
            index= 0;                                                                                         \
        keep && index != size;                                                                                \
        keep = !keep, index++)                                                                                \
      for(item = *(array + index); keep; keep = !keep)
.fi
.PP
A foreach bucle for arrays\&. 
.PP
\fBParameters:\fP
.RS 4
\fIitem\fP The variable type of the initializer for bucle 
.br
\fIarray\fP The array 
.br
\fIsize\fP The length of the array 
.RE
.PP
\fBReturns:\fP
.RS 4
A 'for' loop that traverses all array elements 
.RE
.PP

.SS "#define s_assert(X, Y)   \fB_s_assert\fP(X, Y, __FILE__, __LINE__)"

.PP
Control of errors\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP Test\&. If it evaluates to FALSE it throws an error 
.br
\fIY\fP s_stat data to identifie the throwed error 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing if test evaluates to true\&. Otherwise it throws an error\&. The catcher is the function vstring_Abort 
.RE
.PP

.SH "Typedef Documentation"
.PP 
.SS "typedef \fBvstring_t\fP** \fBarray_vstring_t\fP"

.PP
An array of vstring objects\&. 
.SS "typedef enum \fBS_stat\fP \fBs_stat\fP"

.PP
Control of errors\&. 
.SS "typedef enum \fBS_safe\fP  \fBsafe_t\fP"

.SS "typedef struct \fBVstring\fP  \fBvstring_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBS_safe\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIS_UNSAFE \fP\fP
.TP
\fB\fIS_SAFE \fP\fP
.SS "enum \fBS_stat\fP"

.PP
Control of errors\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIS_OK \fP\fP
All is ok, no errors 
.TP
\fB\fIS_ERR_IS_EMPTY \fP\fP
The Length in the object is Zero 
.TP
\fB\fIS_ERR_VALUE_NOT_FOUND \fP\fP
The object does not contains the data searched 
.TP
\fB\fIS_ERR_OUT_OF_RANGE \fP\fP
The position is out of the bounds 
.TP
\fB\fIS_ERR_FILE \fP\fP
The file is unavoible 
.TP
\fB\fIS_ERR_STACK \fP\fP
The pointer points to the STACK 
.TP
\fB\fIS_ERR_ALLOCATE_MEMORY \fP\fP
Error in Memory Manager with malloc, calloc or realloc 
.TP
\fB\fIS_ERR_MEMCPY \fP\fP
Error in Memory with memcpy function 
.TP
\fB\fIS_ERR_MEMMOVE \fP\fP
Error in Memory with memmove function 
.TP
\fB\fIS_ERR_INVALID_ARGUMENT \fP\fP
The parameters in the function are not valids 
.TP
\fB\fIS_ERR_MAX_CAPACITY \fP\fP
Bound of capacity 
.TP
\fB\fIS_ERR_UNSAFE_CAPACITY \fP\fP
The capacity is inmutable\&. The object is S_SAFE 
.TP
\fB\fIS_ERR_OPEN_FILE \fP\fP
The file is unavoible 
.SH "Function Documentation"
.PP 
.SS "size_t str_Length (char * src, int position, int length, char delimiter)"

.PP
To calculate the lenght of substring in the buffer, from position, to position of the delimiter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP The buffer with the information 
.br
\fIposition\fP Position from that we search the delimiter 
.br
\fIlength\fP Length of the buffer 
.br
\fIdelimiter\fP Delimiter character 
.RE
.PP
\fBReturns:\fP
.RS 4
Two control characters: new line and delimiter\&. If we find '
.br
', it returns Zero\&. If we find 'delimiter char' it returns (index - position)\&. Otherwise returns length Zero of substring\&. 
.RE
.PP

.SS "char* str_Repeat (char * str, size_t count)"

.PP
Copy in the string 'count' times the same string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP The string to repeat 
.br
\fIcount\fP Number of times we want to repeat the string 
.RE
.PP
\fBReturns:\fP
.RS 4
Another pointer, but this time to the HEAP 
.RE
.PP

.SS "char* str_Substring (char * string, int position, int length)"

.PP
To identifie substrings in another string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The buffer to divide from position to (position + length) 
.br
\fIposition\fP Substring from position\&. 
.br
\fIlength\fP Length of desired substring\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This function returns char pointers to Heap\&. That implies the library is responsible to free them\&. It does whith the function Destroy_pointer\&. 
.RE
.PP

.SS "void vstring_Abort (\fBs_stat\fP status, const char * file, int line_number)"

.PP
This function catcher errors that the macro s_assert throws\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfile\fP 
.br
\fIline_number\fP 
.RE
.PP

.SS "void vstring_Array_print (\fBvstring_t\fP * s, const \fBarray_vstring_t\fP array, int size)"

.PP
Print an array of vstring objects\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A pointer to vstring_t object 
.br
\fIarray\fP An array of vstring objects 
.br
\fIsize\fP The number of vstrings objects in array 
.RE
.PP

.SS "\fBs_stat\fP vstring_At (const \fBvstring_t\fP * s, char * item, int position)"

.PP
Character at position in the vstring object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to vstring_t type variable 
.br
\fIitem\fP To copy the value found at searched position 
.br
\fIposition\fP Position to search 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK if position is correct and data is not empty S_ERR_IS_EMPTY if the data is empty S_ERR_OUT_OF_RANGE if position is not ok 
.RE
.PP

.SS "\fBs_stat\fP vstring_Begin (const \fBvstring_t\fP * s, char * item)"

.PP
Item at data's beginning\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to vstring_t type variable 
.br
\fIitem\fP To copy the value found at searched position 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK if data is not empty S_ERR_IS_EMPTY if the vstring object is empty 
.RE
.PP

.SS "int vstring_Capacity (const \fBvstring_t\fP * s)"

.PP
Returns the capacity of the specified object\&. The capacity is the maximum number of characters that an object can hold\&. Capacity has to be greater than Zero\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Object whose capacity is being returned 
.RE
.PP
\fBReturns:\fP
.RS 4
The capacity of the object 
.RE
.PP

.SS "\fBs_stat\fP vstring_Capacity_edit (\fBvstring_t\fP * s, int capacity)"

.PP
To edit the capacity of the vstring object, but only if the object is S_UNSAFE and new capacity is lesser than MAX_CAPACITY\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The object to edit 
.br
\fIcapacity\fP The new capacity 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK or S_ERR_UNSAFE_CAPACITY 
.RE
.PP

.SS "void vstring_Clear (\fBvstring_t\fP * s)"

.PP
Remove the data in the object, but it does not free the object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP It is the object whose data we have to remove 
.RE
.PP

.SS "\fBs_stat\fP vstring_Clear_ifPattern (\fBvstring_t\fP * s, const char * pattern)"

.PP
Remove the data in the object, if matches the pattern\&. We use the C's library 'fnmatch' to pattern matching\&. The pattern may include the following special characters:
.PP
.IP "\(bu" 2
Matches zero of more characters\&. ? Matches exactly one character\&.
.PP
.PP
[\&.\&.\&.] Matches one character if it's in a range of characters\&. If the first character is `!', matches if the character is not in the range\&. Between the brackets, the range is specified by listing the characters that are in the range, or two characters separated by `-' to indicate all characters in that range\&. For example, `[a-d]' matches `a', `b', `c', or `d'\&. If you want to include the literal `-' in the range, make it the first character, like in `[-afz]'\&.
.PP
\\ Causes the next character to not be treated as a wildcard\&. For example, `*' matches an asterisk\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP It is the object whose data we have to remove\&. We do not free the object\&. 
.br
\fIpattern\fP Pattern searched\&. It is a string\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK if the pattern matches, or S_IS_EMPTY if the vstring object is empty or S_ERR_VALUE_NOT_FOUND 
.RE
.PP

.SS "\fBs_stat\fP vstring_Concat (\fBvstring_t\fP * s, \fBvstring_t\fP * t)"

.PP
It concatenates two vstrings objects in the first object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The vstring object we append with the second object 
.br
\fIt\fP vstring object to insert in the first object 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK, or an error S_ERR_UNSAFE_CAPACITY, if the len of the string to append plus the len of the first data object is greater than CAPACITY 
.RE
.PP

.SS "void vstring_Count_words (\fBvstring_t\fP * s, int * count)"

.PP
Count the number of words in a vstring object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The vstring object 
.br
\fIcount\fP Variable to return the number of words in the object 
.RE
.PP

.SS "const char const* vstring_Data (const \fBvstring_t\fP * s)"

.PP
Method to access the string in the vstring object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP the object 
.RE
.PP
\fBReturns:\fP
.RS 4
the string wrapped for the object 
.RE
.PP

.SS "void vstring_Destroy (\fBvstring_t\fP * s)"

.PP
Destructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The vstring object to free 
.RE
.PP

.SS "void vstring_Destroy_Array (\fBarray_vstring_t\fP s, int len)"

.PP
Array destructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The pointer array to free 
.br
\fIlen\fP The number of vstring objects in the array 
.RE
.PP

.SS "\fBs_stat\fP vstring_End (const \fBvstring_t\fP * s, char * item)"

.PP
Item at data's ending\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to vstring_t type variable 
.br
\fIitem\fP To copy the value found at searched position 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK if data is not empty S_ERR_IS_EMPTY if the vstring object is empty 
.RE
.PP

.SS "\fBs_stat\fP vstring_From (\fBvstring_t\fP * s, const char * str)"

.PP
Insert (an item of data) at the end of vstring object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to vstring_t type variable 
.br
\fIitem\fP Value to insert in vstring object 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK, or an error S_ERR_UNSAFE_CAPACITY, if the len of the string to append plus the len of the data object is greater than CAPACITY 
.RE
.PP

.SS "\fBs_stat\fP vstring_From_at (\fBvstring_t\fP * s, const char * str, int position)"

.PP
Insert (an item of data) at position of vstring object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to vstring_t type variable 
.br
\fIstr\fP The string to insert 
.br
\fIposition\fP Position at we insert the string\&. Position is Zero index 
.RE
.PP
\fBReturns:\fP
.RS 4
We control the position\&. The function returns S_OK or an error: S_ERR_IS_EMPTY S_ERR_OUT_OF_RANGE 
.RE
.PP

.SS "void vstring_From_file (\fBvstring_t\fP * s, const char * filename)"

.PP
We copy a file in a vstring object\&. In this case the object is UNSAFE\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The vstring object 
.br
\fIfilename\fP One string with the path and the number of the file\&. 
.RE
.PP

.SS "void vstring_Inmutable (\fBvstring_t\fP * s)"

.PP
Set the object vstring inmutable, that is, SAFE and capacity == len\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP the object vstring 
.RE
.PP

.SS "bool vstring_isEmpty (const \fBvstring_t\fP * s)"

.PP
Returns True if object is Empty, that is, when its length is equal to Zero\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to vstring_t type 
.RE
.PP
\fBReturns:\fP
.RS 4
Bool 
.RE
.PP

.SS "bool vstring_isEquals (const \fBvstring_t\fP * s1, const \fBvstring_t\fP * s2)"

.PP
It Compares the size of elements of two vstrings (s1, s2) and if are equals, it compares the first n bytes of memory area of s1->data and s2->data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP A vstring object 
.br
\fIs2\fP A vstring object 
.RE
.PP
\fBReturns:\fP
.RS 4
True, if s1 and s2 are equals, otherwise False 
.RE
.PP

.SS "int vstring_Len (const \fBvstring_t\fP * s)"

.PP
Returns the number of characters in the data object, the object's length\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to vstring_t type 
.RE
.PP
\fBReturns:\fP
.RS 4
s->len, the number of characters in the data object 
.RE
.PP

.SS "int vstring_Max_capacity (const \fBvstring_t\fP * s)"

.PP
Capacity bound\&. A proportional number over sizeof integer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP the object 
.RE
.PP
\fBReturns:\fP
.RS 4
Capacity bound 
.RE
.PP

.SS "\fBvstring_t\fP* vstring_New (int capacity)"

.PP
Constructor\&. There is no data in the vstring object\&. After 'New', you have to use 'From'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcapacity\fP Maximum number of characters in the object 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a vstring object with its features by default\&. All the objects are safes: their capacity is inmutable 
.RE
.PP

.SS "\fBs_stat\fP vstring_Pattern (\fBvstring_t\fP * s, const char * pattern, \fBvstring_t\fP * result)"

.PP
Returns the strings that matches the pattern in one vstring object\&. In this case, the search is, at least, Big-O lineal time of complexity\&. We use the C's library 'fnmatch' to pattern matching\&. The pattern may include the following special characters: 
.IP "\(bu" 2
Matches zero of more characters\&. ? Matches exactly one character\&.
.PP
.PP
[\&.\&.\&.] Matches one character if it's in a range of characters\&. If the first character is `!', matches if the character is not in the range\&. Between the brackets, the range is specified by listing the characters that are in the range, or two characters separated by `-' to indicate all characters in that range\&. For example, `[a-d]' matches `a', `b', `c', or `d'\&. If you want to include the literal `-' in the range, make it the first character, like in `[-afz]'\&.
.PP
\\ Causes the next character to not be treated as a wildcard\&. For example, `*' matches an asterisk\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A pointer to vstring_t objet 
.br
\fIpattern\fP Pattern searched\&. It is a string\&. 
.br
\fIresult\fP vstring object pointer to return the result 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK if the element was found, or S_IS_EMPTY if the vstring object is empty or S_ERR_VALUE_NOT_FOUND S_ERR_INVALID ARGUMENT 
.RE
.PP

.SS "int vstring_Pos (const \fBvstring_t\fP * s, int position)"

.PP
It calculates new position if it is a negative number\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to vstring_t type variable 
.br
\fIposition\fP Position to calculate 
.RE
.PP
\fBReturns:\fP
.RS 4
New position, if it is a negative number 
.RE
.PP

.SS "\fBs_stat\fP vstring_Pos_Err (const \fBvstring_t\fP * s, int position)"

.PP
Control if supplied position is out of range or object is empty\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to vstring_t type variable 
.br
\fIposition\fP Position to calculate 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK if position is correct and object is not empty S_ERR_IS_EMPTY if the vstring is empty S_ERR_OUT_OF_RANGE if position is not ok 
.RE
.PP

.SS "\fBs_stat\fP vstring_Rep (\fBvstring_t\fP * s, size_t num)"

.PP
It concatenates the source vstring object n times\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The source vstring object 
.br
\fInum\fP Number of times we repeat the vstring object 
.RE
.PP
\fBReturns:\fP
.RS 4
S_OK, or an error S_ERR_UNSAFE_CAPACITY, if the len of the string to append plus the len of the vstring object is greater than CAPACITY 
.RE
.PP

.SS "\fBarray_vstring_t\fP vstring_Split (\fBvstring_t\fP * s, int * len)"

.PP
Split in words the vstring data object\&. The delimiter is SPACE\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A pointer to vstring object 
.br
\fIlen\fP To copy the number of vstrings in the array that is returns 
.RE
.PP
\fBReturns:\fP
.RS 4
An array of vstring objects 
.RE
.PP

.SS "\fBs_stat\fP vstring_Truncate (\fBvstring_t\fP * s, int position)"

.PP
It truncates the data object at position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The data object 
.br
\fIposition\fP The position at we truncate the string 
.RE
.PP
\fBReturns:\fP
.RS 4
We control the position\&. The function returns S_OK or an error: S_ERR_IS_EMPTY S_ERR_OUT_OF_RANGE 
.RE
.PP

.SS "void vstring_Unsafe (\fBvstring_t\fP * s)"

.PP
To edit the state of the vstring object\&. By default the data is inmutable, that is, we does not allow modify its capacity\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The object that we edit its state 
.RE
.PP

.SS "\fBvstring_t\fP* vstring_with_Capacity (char * str, int capacity)"

.PP
Constructor\&. We append the data array with 'str'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP String to append the data in the vstring object 
.br
\fIcapacity\fP Maximum number of characters in the object 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a vstring object with its features by default\&. All the objects are safes: their capacity is inmutable 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for vString from the source code\&.
